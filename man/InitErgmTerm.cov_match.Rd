% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.cov_match.R
\name{InitErgmTerm.cov_match}
\alias{InitErgmTerm.cov_match}
\title{ERGM term: cov_match (monochromatic cliques by actor covariate)}
\usage{
InitErgmTerm.cov_match(nw, arglist, ..., version = packageVersion("ergm"))
}
\arguments{
\item{cov}{character|factor|numeric
Either:
\itemize{
\item the name of an actor-level vertex attribute (factor or character)
defined on all actors in the actor mode; or
\item a vector of length at least \code{|A|} (number of actors), which
is interpreted as an actor-level covariate.
}
In both cases, the covariate is coerced to a factor and then encoded as
integer codes \eqn{1,\dots,R}; \code{NA} values are mapped to 0 (meaning
"absent/undefined" and ignored in clique counts). For numeric covariates,
\code{cov_match} is not meaningful and the initializer fails fast with an
error.}

\item{clique_size}{integer|numeric
One or several clique sizes \eqn{k \ge 1}. The term is vectorized in
\code{clique_size}, so each distinct value of \eqn{k} yields one statistic
and one coefficient. Values are rounded to integers and must be finite and
at least 1.}

\item{category}{character|NULL
Optional targeted category. If \code{NULL}, all categories contribute to
the statistic. If a character string, the initializer ensures that the
category appears in the factor levels; if it does not, the level is added
with zero frequency so that the resulting statistic is structurally zero
without error.}

\item{normalized}{character|logical
Normalization mode, one of:
\itemize{
\item \code{"none"}: raw counts of monochromatic cliques;
\item \code{"by_group"}: per-group normalization by \eqn{\binom{n_g}{k}};
\item \code{"global"}: per-group normalization by \eqn{n_g}, i.e.
each group contribution is divided by its size and the resulting
contributions are summed over groups. Groups with \eqn{n_g = 0}
contribute 0.
}
Logical values are supported as shorthand:
\code{TRUE} is equivalent to \code{"by_group"} and \code{FALSE} to
\code{"none"}.}
}
\value{
A standard {ergm} term specification list with components:
\itemize{
\item \code{name}         = \code{"cov_match"};
\item \code{coef.names}   = coefficient names encoding the covariate label,
clique size, and normalization mode;
\item \code{inputs}       = the \code{INPUT_PARAM} numeric vector described
above;
\item \code{dependence}   = \code{TRUE};
\item \code{emptynwstats} = \code{0}.
}
}
\description{
\code{cov_match} is an ERGM term for bipartite networks that counts
monochromatic cliques of actors within each group, based on a categorical
actor-level covariate. The network is interpreted as:
\itemize{
\item an \emph{actor mode} (the side identified by \code{nw \%n\% "bipartite"});
\item a \emph{group mode} (the complementary side of the bipartite graph).
}

For each group in the group mode and each category of the actor covariate,
the term considers all subsets of actors in that group who share the same
category and counts cliques of size \eqn{k}. Several variants of
normalization are supported:
\itemize{
\item \code{normalized = "none"}: raw counts of monochromatic cliques;
\item \code{normalized = "by_group"}: per-group normalization by
\eqn{\binom{n_g}{k}}, where \eqn{n_g} is group size;
\item \code{normalized = "global"}: per-group normalization by
\eqn{n_g}, i.e. each group contribution is divided by its size
and the resulting terms are summed over groups.
}
An optional targeted category \eqn{\kappa} focuses the statistic on cliques
whose actors all share that specific category.
}
\details{
Let:
\itemize{
\item \eqn{A} be the set of actor-mode nodes, with \eqn{|A| = N_A};
\item \eqn{G} be the set of group-mode nodes;
\item \eqn{B} be the actor–group incidence (bipartite) matrix;
\item \eqn{c : A \to \{1,\dots,R\}} be a categorical covariate assigning a
category \eqn{r} to each actor;
\item \eqn{n_{g,r}} be the number of actors of category \eqn{r} attached to
group \eqn{g};
\item \eqn{n_g = \sum_r n_{g,r}} be the size of group \eqn{g}.
}

For a fixed clique size \eqn{k \ge 1}, define:

\code{
  S_k(B; c)       = sum_g sum_r C(n_{g,r}, k),
}

i.e. the total number of size-\eqn{k} monochromatic subsets of actors within
all groups.

If a targeted category \eqn{\kappa} is specified, define:

\code{
  S_k^{(κ)}(B; c) = sum_g C(n_{g,κ}, k),
}

i.e. the count restricted to actors whose category equals \eqn{\kappa}.

The three normalization modes correspond to:
\itemize{
\item \code{"none"}:
\deqn{
      T_k(B; c) =
      \begin{cases}
        S_k(B; c)             & \text{if no category is targeted}, \\
        S_k^{(\kappa)}(B; c)  & \text{if category } \kappa \text{ is targeted};
      \end{cases}
    }
\item \code{"by_group"}: for each group \eqn{g} we form the ratio
\eqn{\frac{S_k(g)}{\binom{n_g}{k}}} (or
\eqn{\frac{C(n_{g,\kappa}, k)}{\binom{n_g}{k}}} when a category is
targeted), and sum these ratios over groups;
\item \code{"global"}: for each group \eqn{g} we form
\deqn{
      \frac{S_k(g)}{n_g}
      \quad\text{or}\quad
      \frac{C(n_{g,\kappa}, k)}{n_g}
    }
(with the convention that groups of size \eqn{n_g = 0} contribute 0),
and sum these contributions over groups:
\deqn{
      T_k^{\text{global}}(B; c) =
      \sum_{g \in G}
      \begin{cases}
        \dfrac{S_k(g)}{n_g}            & \text{if no category is targeted}, \\
        \dfrac{C(n_{g,\kappa}, k)}{n_g}& \text{if category } \kappa \text{ is targeted}.
      \end{cases}
    }
}

The term is vectorized in \code{clique_size}: several values of \eqn{k} can
be specified, yielding one statistic per \eqn{k}.

The term is implemented as a native ERGM C change-statistic
\code{c_cov_match}. The R initializer below:
\itemize{
\item enforces that the network is bipartite and retrieves the actor-mode
size from \code{nw \%n\% "bipartite"};
\item validates that the actor covariate is categorical (factor/character)
and encodes it into integer codes \eqn{0, 1, \dots, R};
\item handles the optional targeted category by mapping it to its level
index \eqn{\kappa};
\item maps the normalization choice to an internal integer flag;
\item builds a compact \code{INPUT_PARAM} vector encoding the actor-mode
size, the clique sizes, normalization mode, and covariate codes.
}
}
\note{
InitErgmTerm.cov_match.R

\itemize{
\item The network must be bipartite and interpreted as actors versus groups.
The actor mode is identified by \code{nw \%n\% "bipartite"} and must
be a strictly positive integer.
\item The covariate must be categorical (factor or character). Numeric
vectors are rejected fail-fast because \code{cov_match} relies on
category frequencies, not continuous values.
\item By default, \code{clique_size = 1} with \code{normalized = "none"} or
\code{"global"} is disallowed, because the statistic is then constant
under edge toggles in the typical ERPM partition setting. This behavior
can be overridden (for advanced use) by setting:
\code{options(ERPM.allow.k1.nonnormalized = TRUE)}.
\item Debug logging for the initializer can be enabled via:
\code{options(erpm.debug.cov_match_init = TRUE)}. When enabled, the
initializer prints diagnostic information about actor-mode size,
clique sizes, normalization mode, and covariate level mapping.
}
}
\section{INPUT_PARAM layout (C side)}{

The numeric input vector passed to \code{c_cov_match} is:

\code{
  INPUT_PARAM = c(
    n1,          # actor-mode size |A|
    K,           # number of distinct clique sizes
    norm_mode,   # 0=none, 1=by_group, 2=global
    has_kappa,   # 0/1: whether a targeted category is used
    kappa_code,  # level index of the targeted category (0 if none)
    ks[1:K],     # vector of clique sizes k >= 1
    z[1:n1]      # actor covariate codes (0=missing / undefined, 1..R for levels)
  )
}

On each toggle of an actor–group edge, the C code recomputes the local
contribution for the affected group and updates the statistic accordingly,
respecting the chosen normalization and targeted category.
}

\section{Arguments}{

The initializer is called internally by {ergm} and should not be invoked
directly by users. The user-facing term is:

\code{
  cov_match(cov,
            clique_size = 2,
            category    = NULL,
            normalized  = c("none","by_group","global"))
}
}

\section{Tests}{

Self-tests for \code{cov_match} (not shown here) typically:
\itemize{
\item construct small bipartite networks with an explicit partition of
actors into groups and a known categorical covariate;
\item compute the reference counts of monochromatic cliques of size
\eqn{k} directly in R, both with and without a targeted category,
and under each normalization mode ("none", "by_group", "global");
\item compare these reference values to
\code{summary(nw ~ cov_match(...), constraints = ~ b1part)};
\item check that toggling a single actor–group edge modifies the statistic
by a difference that matches the local recomputation of clique counts
in the affected group, in agreement with the C change-statistic
\code{c_cov_match}.
}
}

\examples{
\dontrun{
  library(network)
  library(ergm)

  # -----------------------------------------------------------------------
  # Build a small bipartite network: 5 actors, 2 groups
  # -----------------------------------------------------------------------
  n_actors <- 5
  n_groups <- 2
  n_total  <- n_actors + n_groups

  adj <- matrix(0, n_total, n_total)

  # Actors = 1..5, Groups = 6..7
  # Group 6: actors 1, 2, 3
  adj[1, 6] <- adj[6, 1] <- 1
  adj[2, 6] <- adj[6, 2] <- 1
  adj[3, 6] <- adj[6, 3] <- 1
  # Group 7: actors 3, 4, 5
  adj[3, 7] <- adj[7, 3] <- 1
  adj[4, 7] <- adj[7, 4] <- 1
  adj[5, 7] <- adj[7, 5] <- 1

  nw <- network(adj, directed = FALSE, matrix.type = "adjacency")
  nw \%n\% "bipartite" <- n_actors  # actor-mode size

  # Actor covariate: two categories "A" / "B"
  cov_vals <- c("A", "A", "B", "B", "A")
  set.vertex.attribute(nw, "grp", c(cov_vals, rep(NA, n_groups)))

  # -----------------------------------------------------------------------
  # Example 1: raw counts of k=2 monochromatic cliques (pairs)
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match("grp", clique_size = 2, normalized = "none"),
    constraints = ~ b1part
  )

  # -----------------------------------------------------------------------
  # Example 2: k=2 with by-group normalization
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match("grp", clique_size = 2, normalized = "by_group"),
    constraints = ~ b1part
  )

  # -----------------------------------------------------------------------
  # Example 3: targeted category, k=3, global normalization (by group size)
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match("grp", clique_size = 3,
                   category   = "A",
                   normalized = "global"),
    constraints = ~ b1part
  )

  # Example ERGM fit with two clique sizes
  fit <- ergm(
    nw ~ cov_match("grp", clique_size = c(2, 3), normalized = "by_group"),
    constraints = ~ b1part
  )
  summary(fit)

  # Example call through the ERPM wrapper (network already bipartite)
  # erpm(nw ~ cov_match("grp", clique_size = 2, normalized = "by_group"))
}

}
\keyword{ERGM}
\keyword{bipartite}
\keyword{categorical}
\keyword{cliques}
\keyword{covariate}
\keyword{monochromatic}
\keyword{term}
