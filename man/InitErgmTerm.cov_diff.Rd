% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.cov_diff.R
\name{InitErgmTerm.cov_diff}
\alias{InitErgmTerm.cov_diff}
\title{ERGM term: cov_diff (range over k-actor subsets within groups)}
\usage{
InitErgmTerm.cov_diff(nw, arglist, ..., version = packageVersion("ergm"))
}
\description{
\code{cov_diff} is an ERGM term for bipartite networks that measures, for each
group, the dispersion of a numeric actor covariate over all \eqn{k}-actor
subsets within that group. The bipartite network is interpreted as:
\itemize{
\item an \emph{actor mode} (the side identified by \code{nw \%n\% "bipartite"});
\item a \emph{group mode} (the complementary side, representing groups).
}

Each actor in the actor mode carries a numeric covariate value \eqn{x_i}.
For a fixed integer \eqn{k \ge 2}, and for each group, the term considers all
\eqn{k}-actor subsets of that group and computes, on each subset, the
max–min range of the covariate. The statistic can be used either in its raw
form (sum over all subsets in all groups) or in a by-group normalized form
(average range per group), controlled by the \code{normalized} argument.
}
\details{
The term is implemented as a native ERGM C change-statistic, declared in the
compiled code under a symbol compatible with \code{name = "cov_diff"}. The R
initializer below:
\itemize{
\item enforces that the network is bipartite via \code{nw \%n\% "bipartite"};
\item extracts an actor-level covariate from a vertex attribute or from a
literal vector, coercing it to numeric and failing fast on \code{NA};
\item normalizes the \code{clique_size} argument into a single integer
\eqn{k \ge 2};
\item interprets \code{normalized} as either:
\itemize{
\item \code{FALSE}/\code{"none"}: raw sum over all \eqn{k}-subsets;
\item \code{TRUE}/\code{"by_group"}: group-wise average over
\eqn{k}-subsets;
}
\item packs the covariate and scalar parameters into a compact
\code{INPUT_PARAM} vector for the C layer.
}

The ERGM infrastructure will call the C change-statistic whenever a toggle
affects an edge between an actor and a group. The C code recomputes the
local contribution of the affected group(s) to the \eqn{k}-subset range sum.
}
\note{
InitErgmTerm.cov_diff.R

The network must be strictly bipartite:
\itemize{
\item the actor mode size is given by \code{nw \%n\% "bipartite"} and must be
a positive integer;
\item the group mode is the complementary set of nodes;
\item the covariate is read on the actor mode only.
}

The covariate is coerced to numeric if possible (logical and integer types
are accepted), and any \code{NA} on the actor mode is rejected in a
fail-fast manner. The \code{clique_size} argument must be a single finite
numeric value that is rounded to an integer \eqn{k \ge 2}. The
\code{normalized} argument accepts logical values, the character strings
\code{"none"} and \code{"by_group"}, or a scalar numeric flag interpreted as
zero (raw) versus non-zero (by-group).

Internally, \code{cov_diff} passes its parameters and covariate to the C
layer through \code{INPUT_PARAM} with layout
\code{c(n1, k, norm_flag, x[1:n1])}, where:
\itemize{
\item \code{n1} is the actor-mode size;
\item \code{k} is the subset size \eqn{k};
\item \code{norm_flag} equals \code{0} for raw, \code{1} for by-group;
\item \code{x} is the numeric actor covariate restricted to the actor mode.
}
}
\section{Mathematical definition}{

Let:
\itemize{
\item \eqn{A} be the set of actor-mode nodes;
\item \eqn{G} be the set of group-mode nodes;
\item \eqn{B} the bipartite adjacency between actors and groups;
\item \eqn{x_i \in \mathbb{R}} the numeric covariate value of actor
\eqn{i \in A};
\item \eqn{A_g = \{ i \in A : B_{ig}=1\}} the set of actors in group
\eqn{g \in G};
\item \eqn{n_g = |A_g|} the size of group \eqn{g};
\item \eqn{\mathcal{C}_k(g)} the family of all \eqn{k}-element subsets of
\eqn{A_g}.
}

For each subset \eqn{S \in \mathcal{C}_k(g)}, define its range as
\deqn{
  R(S) = \max_{i \in S} x_i - \min_{i \in S} x_i.
}
The \emph{raw} statistic is
\deqn{
  T_k^{\text{raw}}(B;x)
  =
  \sum_{g \in G}
  \sum_{S \in \mathcal{C}_k(g)} R(S),
}
where groups with \eqn{n_g < k} contribute zero (they have no
\eqn{k}-subsets). The \emph{by-group normalized} statistic divides each group
contribution by the number of \eqn{k}-subsets in that group, i.e.
\deqn{
  T_k^{\text{by-group}}(B;x)
  =
  \sum_{g \in G}
    \mathbf{1}[\,n_g \ge k\,]
    \frac{1}{\binom{n_g}{k}}
    \sum_{S \in \mathcal{C}_k(g)} R(S).
}

The argument \code{normalized} selects between these two variants.
}

\section{Usage}{

Typical usage with {ergm} on a bipartite network \code{nw}:
\preformatted{
  # Raw (non-normalized) cov_diff on actor covariate "x_attr" with k = 2
  summary(nw ~ cov_diff(cov = "x_attr", clique_size = 2, normalized = FALSE))

  # By-group normalized variant
  summary(nw ~ cov_diff(cov = "x_attr", clique_size = 3, normalized = TRUE))
}

When using the ERPM wrapper on a partition-based workflow, the term can be
invoked indirectly as:
\preformatted{
  erpm(partition ~ cov_diff(cov = "x_attr", clique_size = 2, normalized = TRUE))
}
provided that the wrapper translates the partition into a bipartite network
with a consistent actor mode and group mode.
}

\section{Tests}{

Self-tests for \code{cov_diff} construct small bipartite networks with
known group memberships and numeric covariates, and compare:
\itemize{
\item the ERGM summary \code{summary(nw ~ cov_diff(...))};
\item direct evaluations of
\eqn{\sum_g \sum_{S \in \mathcal{C}_k(g)} (\max_{i \in S} x_i - \min_{i \in S} x_i)}
(raw case);
\item direct evaluations of
\eqn{\sum_g \mathbf{1}[n_g \ge k] \binom{n_g}{k}^{-1}
              \sum_{S \in \mathcal{C}_k(g)} (\max_{i \in S} x_i - \min_{i \in S} x_i)}
(by-group normalized case).
}
Additional checks verify that toggling an actor–group tie updates the
statistic by the expected local change in the range over all \eqn{k}-subsets
within the affected group, including cases where the group size crosses
the threshold \eqn{n_g = k}.
}

\examples{
\dontrun{
  library(network)
  library(ergm)

  # Build a small bipartite network: 4 actors, 2 groups
  n_actors <- 4
  n_groups <- 2
  n_total  <- n_actors + n_groups

  # Adjacency: actors 1..4, groups 5..6
  adj <- matrix(0, n_total, n_total)

  # Group 5 has actors 1,2,3
  adj[1, 5] <- adj[5, 1] <- 1
  adj[2, 5] <- adj[5, 2] <- 1
  adj[3, 5] <- adj[5, 3] <- 1

  # Group 6 has actors 2,4
  adj[2, 6] <- adj[6, 2] <- 1
  adj[4, 6] <- adj[6, 4] <- 1

  nw <- network(adj, directed = FALSE, matrix.type = "adjacency")
  nw \\%n\\% "bipartite" <- n_actors  # actor mode size

  # Numeric covariate on the actor mode
  x_attr <- c(1.0, 3.0, 5.0, 10.0)
  set.vertex.attribute(nw, "x_attr", c(x_attr, rep(NA_real_, n_groups)))

  # Example: k = 2 (all 2-actor subsets inside each group)
  summary(nw ~ cov_diff(cov = "x_attr", clique_size = 2))

  # By-group normalized variant
  summary(nw ~ cov_diff(cov = "x_attr", clique_size = 2, normalized = TRUE))

  # Fit a simple ERGM including the term
  fit <- ergm(nw ~ cov_diff(cov = "x_attr", clique_size = 2))
  summary(fit)
}

}
\keyword{ERGM}
\keyword{bipartite}
\keyword{covariate}
\keyword{groups}
\keyword{range}
\keyword{subsets}
\keyword{term}
