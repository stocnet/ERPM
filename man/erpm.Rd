% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/erpm_wrapper.R
\name{erpm}
\alias{erpm}
\title{ERPM main wrapper: translate and optionally fit with {ergm}}
\usage{
erpm(
  formula,
  eval_call = TRUE,
  verbose = TRUE,
  estimate = NULL,
  eval.loglik = NULL,
  control = NULL,
  timeout = NULL,
  nodes = NULL,
  dyads = list()
)
}
\arguments{
\item{formula}{\verb{lhs ~ <ERPM terms>}, where \code{lhs} is either a partition
vector or an already built bipartite \code{network} object.}

\item{eval_call}{logical. If TRUE evaluate the {ergm} call, else return it.}

\item{verbose}{logical. If TRUE print wrapper translation log and options.
When explicitly set in the \code{erpm()} call, its value is also forwarded
to \code{ergm()} as the \code{verbose=} argument.}

\item{estimate}{character or NULL.
If non-NULL, its value is forwarded to \code{ergm()} as the
\code{estimate=} argument, after a light normalization that maps
\code{"MCMLE"} to \code{"MLE"}. If NULL, no \code{estimate} argument is
supplied and \code{ergm()} uses its own default.}

\item{eval.loglik}{logical or NULL.
If non-NULL, its value is forwarded to \code{ergm()} as the
\code{eval.loglik=} argument. If NULL, no \code{eval.loglik}
argument is supplied and \code{ergm()} uses its own default
(possibly depending on \code{estimate} and \code{control}).}

\item{control}{list or \code{control.ergm} object, or NULL.
If NULL, \code{ergm()} receives no \code{control} argument and uses its defaults.
When a control object with an \code{init} vector of incompatible length
is passed, the wrapper drops \code{init} to let {ergm} recompute its
defaults.}

\item{timeout}{numeric seconds; if set, evaluation runs under
\code{R.utils::withTimeout}.}

\item{nodes}{optional data.frame for actor attributes and labels.
Used only when the LHS is a partition vector.}

\item{dyads}{optional list of n√ón matrices to attach to \verb{\%n\%}.
Used only when the LHS is a partition vector.}
}
\value{
If \code{eval_call=TRUE}, an {ergm} fit. Otherwise, the unevaluated call.
}
\description{
This function:
\enumerate{
\item Interprets the LHS of a formula as either a partition vector
or a pre-built bipartite {network};
\item Builds a bipartite network from a partition if needed;
\item Splits and translates ERPM RHS terms into {ergm} terms;
\item Constructs an \code{ergm()} call with constraint \code{~ b1part};
\item Either returns the unevaluated call (dry-run) or evaluates it.
}
}
\note{
The wrapper always imposes the \code{b1part} constraint and assumes a bipartite
representation of the partition. The internal translation layer can later
be extended by populating \code{effect_rename_map}, \code{wrap_with_proj1},
and \code{wrap_with_B}.

The behavior of \code{erpm()} is exercised in self-tests that compare
ERPM-based fits to direct {ergm} calls on constructed bipartite networks.
}
\examples{
\dontrun{
  # Translate only
  partition <- c(1, 1, 2, 2, 3)
  call_only <- erpm(partition ~ groups(2), eval_call = FALSE)
  print(call_only)

  # Fit immediately with explicit estimate
  fit <- erpm(partition ~ groups + cliques(3), estimate = "MLE")
}

}
