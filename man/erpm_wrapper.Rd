% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/erpm_wrapper.R
\name{erpm_wrapper}
\alias{erpm_wrapper}
\title{ERPM wrapper: translate ERPM formulas to {ergm} calls and optionally fit}
\arguments{
\item{a}{any R object, possibly \code{NULL}}

\item{b}{any R object used as fallback}

\item{s}{character scalar}

\item{x}{any R object}

\item{prefer}{character scalar, preferred label column name}

\item{n}{integer number of actors (mode 1)}

\item{labels}{character vector of actor labels, used for name checks}

\item{msg}{character scalar, specific error message}

\item{partition}{integer vector of group ids, length n, values in 1..G}

\item{args_list}{list of arguments as captured from the call}

\item{expr}{a language object representing the RHS expression}

\item{term_call}{a call object representing a single RHS term}

\item{rename_map}{named character vector mapping old → new term names}

\item{wrap_proj1}{character vector of term names to wrap in \code{Proj1(~ term)}}

\item{wrap_B}{character vector of term names to wrap in \code{B(~ term, form="nonzero")}}

\item{formula}{\verb{lhs ~ <ERPM terms>}, where \code{lhs} is either a partition
vector or an already built bipartite \code{network} object.}

\item{eval_call}{logical. If TRUE evaluate the {ergm} call, else return it.}

\item{verbose}{logical. If TRUE print wrapper translation log and options.
When explicitly set in the \code{erpm()} call, its value is also forwarded
to \code{ergm()} as the \code{verbose=} argument.}

\item{estimate}{character or NULL.
If non-NULL, its value is forwarded to \code{ergm()} as the
\code{estimate=} argument, after a light normalization that maps
\code{"MCMLE"} to \code{"MLE"}. If NULL, no \code{estimate} argument is
supplied and \code{ergm()} uses its own default.}

\item{eval.loglik}{logical or NULL.
If non-NULL, its value is forwarded to \code{ergm()} as the
\code{eval.loglik=} argument. If NULL, no \code{eval.loglik}
argument is supplied and \code{ergm()} uses its own default
(possibly depending on \code{estimate} and \code{control}).}

\item{control}{list or \code{control.ergm} object, or NULL.
If NULL, \code{ergm()} receives no \code{control} argument and uses its defaults.
When a control object with an \code{init} vector of incompatible length
is passed, the wrapper drops \code{init} to let {ergm} recompute its
defaults.}

\item{timeout}{numeric seconds; if set, evaluation runs under
\code{R.utils::withTimeout}.}

\item{nodes}{optional data.frame for actor attributes and labels.
Used only when the LHS is a partition vector.}

\item{dyads}{optional list of n×n matrices to attach to \verb{\%n\%}.
Used only when the LHS is a partition vector.}
}
\value{
\code{a} if not \code{NULL}, otherwise \code{b}

character scalar

character scalar without whitespace

logical, \code{TRUE} if \code{x} is a bipartite network

character scalar column name or \code{NULL} if none found

invisibly \code{TRUE} on success; otherwise raises an error

invisibly \code{TRUE} on success; otherwise raises an error

this function always calls \code{\link[base:stop]{base::stop()}}

list with components:
\itemize{
\item \code{network}: the bipartite {network} object;
\item \code{partition}: the original partition vector;
\item \code{actor_labels}: character vector of actor labels;
\item \code{group_labels}: character vector of group labels.
}

list with elements \code{from} (integer) and \code{to} (integer or \code{quote(Inf)})

list of call objects (each element is either a call or an atomic term)

a translated call suitable for {ergm}

If \code{eval_call=TRUE}, an {ergm} fit. Otherwise, the unevaluated call.
}
\description{
This module provides a thin wrapper around {ergm} to:
\enumerate{
\item Build a bipartite network from a partition, with optional node and dyadic inputs.
\item Translate ERPM RHS terms (e.g., \code{groups}, \code{cov_match}, \code{cliques})
into {ergm} terms, with optional encapsulations (\code{Proj1}, \code{B}).
\item Compose a standard call \code{ergm(nw ~ <translated RHS>, constraints = ~ b1part, ...)}.
\item Either return the call (dry-run) or evaluate it and return the fitted model.
}

The file also includes:
\itemize{
\item argument normalizers for ERPM-specific terms such as \code{groups(...)};
\item internal validators for node data and dyadic covariates;
\item a builder for bipartite networks from partitions;
\item a single-term translator used by the ERPM→{ergm} translation layer.
}

All user-facing console messages are in English for consistency with {ergm}.
}
\note{
erpm_wrapper.R

This wrapper assumes that the user has attached the {ergm} and {network} packages
(or that they are available in the search path) and that the \code{b1part}
constraint is meaningful for the constructed network.

The main wrapper is exercised in self-tests and MWEs under \code{scripts/test}
by comparing ERPM-based fits to direct {ergm} calls on constructed bipartite networks.

This is a small utility for readability; it does not introduce any new
semantics beyond a standard \code{if (is.null(a)) b else a}.

See tests where wrapper options are normalized using \verb{\%||\%}.

Width cutoff is fixed at 500L to reduce line breaks when deparsing formulas.

Used in logging inside \code{erpm()} for user-facing messages.

Unlike a simple trimming, this removes \emph{all} whitespace tokens.
This matches the current behavior of the ERPM logging format.

Checked implicitly by tests that compare log messages in error paths.

This helper is currently not used inside this file but kept for potential
future sanity checks on user-supplied networks.

May be exercised in higher-level tests that inspect pre-built networks.

The aliases include "label", "nom", "name", and "id" to be robust
to typical naming patterns in user data.

\code{build_bipartite_from_inputs()} indirectly tests this helper by using
various node input configurations.

The label column is chosen using \code{.get_label_col()} and may be NULL
if no reasonable candidate is found.

Used by \code{build_bipartite_from_inputs()} when validating node inputs.

This helper does not attach the matrices; it only validates their shape
and naming. Attachment is performed in \code{build_bipartite_from_inputs()}.

Tested indirectly by ERPM self-tests using dyadic covariates.

This function is not exported. It is used internally by
\code{build_bipartite_from_inputs()}.

The content of the usage message is not asserted, but calls from
invalid inputs should raise an error including the provided \code{msg}.

This builder is used by \code{erpm()} when the LHS of the formula is
a partition vector rather than a pre-built network.
The bipartite attribute is set to \code{n} so that \code{constraints = ~ b1part}
is meaningful for {ergm}.

Self-tests construct bipartite networks from partitions and compare their
summaries to reference partitions.

This normalizer is used exclusively by \code{.translate_one_term()} for
the special-case translation of \code{groups(...)} into \code{b2degrange}.

Covered indirectly by tests that exercise ERPM formulas with \code{groups()}.

This is a syntactic splitter. It does not interpret the meaning of the
underlying terms; it only follows the binary \code{+} structure.

Used by \code{erpm()} to translate each term independently.

In the current version, \code{rename_map}, \code{wrap_proj1}, and \code{wrap_B}
are typically empty, but they are kept for forward compatibility with other
ERPM terms that may be translated into standard ERGM effects.

Indirectly tested by ERPM self-tests that use \code{groups()} and \code{cliques()}
in ERPM formulas.

The wrapper always imposes the \code{b1part} constraint and assumes a bipartite
representation of the partition. The internal translation layer can later
be extended by populating \code{effect_rename_map}, \code{wrap_with_proj1},
and \code{wrap_with_B}.

The behavior of \code{erpm()} is exercised in self-tests that compare
ERPM-based fits to direct {ergm} calls on constructed bipartite networks.
}
\examples{
\dontrun{
  # Basic usage from a partition vector
  partition <- c(1, 1, 2, 2, 3)
  fit <- erpm(partition ~ groups + cliques(3), estimate = "MLE")

  # Dry-run: only inspect the translated {ergm} call
  call_only <- erpm(partition ~ groups(2), eval_call = FALSE)
  print(call_only)
}

1 \%||\% 2
NULL \%||\% 2

.oneline(quote(a + b + c))

.tight(" a  +  b \n c ")

\dontrun{
  is_bipartite_network(nw)
}

df <- data.frame(id = 1:3, name = c("A","B","C"))
.get_label_col(df)

df <- data.frame(label = c("A","B","C"))
.check_nodes_df(df)

M <- diag(3)
.check_dyads(list(ex = M), n = 3, labels = c("A","B","C"))

\dontrun{
  .stop_build_bipartite("partition must be non-empty")
}

\dontrun{
  partition <- c(1, 1, 2, 2, 3)
  nodes <- data.frame(
    label = paste0("A", 1:5),
    age   = c(20, 21, 22, 23, 24)
  )
  friendship <- matrix(0, 5, 5)
  built <- build_bipartite_from_inputs(partition, nodes = nodes,
                                      dyads = list(friendship = friendship))
  nw <- built$network
}

.normalize_groups_args(list())
.normalize_groups_args(list(3))
.normalize_groups_args(list(from = 2, to = 5))

expr <- quote(edges + triangles + nodematch("grp"))
.split_sum_terms(expr)

.translate_one_term(quote(groups(3)), rename_map = c())
.translate_one_term(quote(cliques(k = 3, normalized = TRUE)), rename_map = c())

\dontrun{
  # Translate only
  partition <- c(1, 1, 2, 2, 3)
  call_only <- erpm(partition ~ groups(2), eval_call = FALSE)
  print(call_only)

  # Fit immediately with explicit estimate
  fit <- erpm(partition ~ groups + cliques(3), estimate = "MLE")
}

}
\keyword{"bipartite"`}
\keyword{"nonzero")}.}
\keyword{(dry-run)}
\keyword{(from,}
\keyword{(mode-1}
\keyword{(spaces,}
\keyword{(unused}
\keyword{+}
\keyword{...)}}
\keyword{...,}
\keyword{/}
\keyword{0};}
\keyword{=}
\keyword{Bare}
\keyword{Build}
\keyword{Builds}
\keyword{Centralize}
\keyword{Check}
\keyword{Construct}
\keyword{Constructs}
\keyword{Convert}
\keyword{Decompose}
\keyword{ERGM}
\keyword{ERPM}
\keyword{Either}
\keyword{Ensure}
\keyword{Guess}
\keyword{Helper}
\keyword{Interprets}
\keyword{It}
\keyword{LHS}
\keyword{Minimal}
\keyword{Normalize}
\keyword{Null-coalescing}
\keyword{One-line}
\keyword{Preference}
\keyword{RHS}
\keyword{Remove}
\keyword{Replace}
\keyword{Requirements:}
\keyword{Return}
\keyword{Rules:}
\keyword{Search}
\keyword{Split}
\keyword{Splits}
\keyword{Supported}
\keyword{The}
\keyword{These}
\keyword{This}
\keyword{Translate}
\keyword{Used}
\keyword{Validate}
\keyword{\code{B(~}
\keyword{\code{Proj1(~}
\keyword{\code{b2degrange(from,}
\keyword{\code{build_bipartite_from_inputs()},}
\keyword{\code{cliques(...)}:}
\keyword{\code{edges}
\keyword{\code{ergm()}}
\keyword{\code{from}}
\keyword{\code{groups(...)}}
\keyword{\code{groups(from}
\keyword{\code{groups(k)}}
\keyword{\code{groups(size}
\keyword{\code{groups}}
\keyword{\code{prefer},}
\keyword{\code{rename_map}}
\keyword{\code{to}}
\keyword{\code{~}
\keyword{\enumerate{}
\keyword{\eqn{G}
\keyword{\eqn{\ge}
\keyword{\eqn{n}}
\keyword{\item}
\keyword{\itemize{}
\keyword{`%n%}
\keyword{`%n%`}
\keyword{`Inf`}
\keyword{`Inf`;}
\keyword{`NULL`,}
\keyword{`a`}
\keyword{`b`.}
\keyword{`else`}
\keyword{`from`}
\keyword{`from`.}
\keyword{`groups(...)`}
\keyword{`if`}
\keyword{`nodes`}
\keyword{`to`,}
\keyword{a}
\keyword{actor}
\keyword{actors),}
\keyword{aliases}
\keyword{aliases.}
\keyword{all}
\keyword{allowed}
\keyword{an}
\keyword{and}
\keyword{are}
\keyword{arguments}
\keyword{as}
\keyword{attached}
\keyword{attribute.}
\keyword{attributes}
\keyword{attributes.}
\keyword{avoid}
\keyword{b1part};}
\keyword{be}
\keyword{become}
\keyword{bipartite}
\keyword{builder:}
\keyword{but}
\keyword{by}
\keyword{call}
\keyword{call.}
\keyword{calls}
\keyword{column}
\keyword{common}
\keyword{compact}
\keyword{compactify}
\keyword{constraint}
\keyword{contain}
\keyword{corresponding}
\keyword{data}
\keyword{data.frame,}
\keyword{data.frame;}
\keyword{default}
\keyword{deparser}
\keyword{duplicates.}
\keyword{dyadic}
\keyword{each}
\keyword{either}
\keyword{empty}
\keyword{entry}
\keyword{error}
\keyword{evaluates}
\keyword{every}
\keyword{example.}
\keyword{exists,}
\keyword{expression}
\keyword{failures}
\keyword{finite}
\keyword{finiteness}
\keyword{fit}
\keyword{for}
\keyword{form}
\keyword{formula}
\keyword{formulas}
\keyword{frame}
\keyword{from}
\keyword{from:}
\keyword{function}
\keyword{function:}
\keyword{generic}
\keyword{greater}
\keyword{groups}
\keyword{if}
\keyword{in}
\keyword{inside}
\keyword{integer}
\keyword{internal}
\keyword{interval}
\keyword{into}
\keyword{is}
\keyword{is:}
\keyword{it}
\keyword{it.}
\keyword{k)}}
\keyword{keep}
\keyword{label}
\keyword{label-like}
\keyword{labels.}
\keyword{later}
\keyword{length}
\keyword{like}
\keyword{list}
\keyword{logging}
\keyword{logging.}
\keyword{looks}
\keyword{main}
\keyword{match}
\keyword{matrices}
\keyword{matrices,}
\keyword{matrix;}
\keyword{maximize}
\keyword{message}
\keyword{messages.}
\keyword{minimal}
\keyword{mode-2}
\keyword{must}
\keyword{name;}
\keyword{needed;}
\keyword{nested}
\keyword{network}
\keyword{newlines)}
\keyword{node}
\keyword{nodematch("grp")}}
\keyword{normalize}
\keyword{not}
\keyword{nothing.}
\keyword{number}
\keyword{n}}
\keyword{n×n}
\keyword{n×n;}
\keyword{object}
\keyword{objects,}
\keyword{of}
\keyword{on}
\keyword{operator}
\keyword{optional}
\keyword{optionally}
\keyword{or}
\keyword{order.}
\keyword{order:}
\keyword{otherwise}
\keyword{padded}
\keyword{pads}
\keyword{partition}
\keyword{pre-built}
\keyword{presence}
\keyword{present,}
\keyword{processing.}
\keyword{provide}
\keyword{recursively}
\keyword{renames}
\keyword{representing}
\keyword{reproducible}
\keyword{return}
\keyword{returns}
\keyword{row/colnames}
\keyword{run}
\keyword{same}
\keyword{set}
\keyword{signatures:}
\keyword{single}
\keyword{single-line}
\keyword{small}
\keyword{so}
\keyword{square}
\keyword{stop}
\keyword{stored}
\keyword{strictly}
\keyword{string}
\keyword{suitable}
\keyword{sum-of-terms}
\keyword{supports:}
\keyword{symbols}
\keyword{tabs,}
\keyword{takes}
\keyword{term}
\keyword{term)}}
\keyword{term,}
\keyword{term.}
\keyword{terms}
\keyword{terms;}
\keyword{test}
\keyword{testing}
\keyword{than}
\keyword{that}
\keyword{the}
\keyword{then}
\keyword{they}
\keyword{throughout}
\keyword{to}
\keyword{to)}
\keyword{to)};}
\keyword{translate}
\keyword{translates}
\keyword{translation}
\keyword{triangles}
\keyword{turned}
\keyword{unevaluated}
\keyword{unify}
\keyword{usage}
\keyword{used}
\keyword{validation}
\keyword{values.}
\keyword{variability}
\keyword{vector}
\keyword{vertices).}
\keyword{via}
\keyword{whitespace}
\keyword{with}
\keyword{wrapper}
\keyword{wrapper:}
\keyword{wrapping}
\keyword{zero-argument}
\keyword{{ergm}}
\keyword{{network}}
\keyword{{network};}
\keyword{}}
\keyword{→}
