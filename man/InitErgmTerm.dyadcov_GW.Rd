% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.dyadcov_GW.R
\name{InitErgmTerm.dyadcov_GW}
\alias{InitErgmTerm.dyadcov_GW}
\title{ERGM term: dyadcov_GW (geometrically weighted dyadic covariate)}
\usage{
InitErgmTerm.dyadcov_GW(nw, arglist, ...)
}
\arguments{
\item{dyadcov}{matrix or character. Either:
\itemize{
\item a numeric matrix of size at least \code{n1 x n1}, where
\code{n1 = nw \%n\% "bipartite"} is the actor-mode size; or
\item the name of a network-level attribute containing such a matrix
(retrieved as \code{nw \%n\% dyadcov}).
}
In both cases the matrix is truncated, if necessary, to its top-left
\code{n1 x n1} block.}

\item{lambda}{numeric scalar. Geometric weight parameter \eqn{\lambda > 0}.
Typical usage sets \eqn{\lambda > 1} to ensure decaying weights in
\eqn{a_k(\lambda) = (-1/\lambda)^{k-1}}, but the initializer only requires
\eqn{\lambda > 0} and finiteness.}
}
\value{
A standard {ergm} term initialization list with components:
\itemize{
\item \code{name}         = \code{"dyadcov_GW"};
\item \code{coef.names}   = a single coefficient name encoding the
dyadic covariate label and the value of \code{lambda};
\item \code{inputs}       = numeric vector
\code{c(n1, lambda, as.double(Z))};
\item \code{dependence}   = \code{TRUE};
\item \code{minval}       = \code{-Inf};
\item \code{maxval}       = \code{Inf};
\item \code{emptynwstats} = \code{0}.
}
}
\description{
\code{dyadcov_GW} is an ERGM term for bipartite networks that builds a
geometrically weighted aggregation of a dyadic covariate
\eqn{Z = (z_{ij})} over actor cliques within each group.

The network is interpreted as:
\itemize{
\item an \emph{actor mode} (the side identified by \code{nw \%n\% "bipartite"});
\item a \emph{group mode} (the complementary side of the bipartite graph).
}

For each group in the group mode, we consider its incident actors, all
\eqn{k}-subsets of these actors, and the products of \emph{symmetrised}
dyadic covariates \eqn{z_{ij} + z_{ji}} over each subset. These clique
contributions are then combined across clique sizes \eqn{k \ge 2} with a
geometric weight controlled by \eqn{\lambda}.
}
\details{
The core statistic for a given partition \eqn{p}, dyadic covariate \eqn{Z},
and scalar \eqn{\lambda > 0} is:
}
\note{
InitErgmTerm.dyadcov_GW.R

\itemize{
\item The network must be bipartite and interpreted as actors versus groups.
\item The actor mode is identified by \code{nw \%n\% "bipartite"} and must
be a strictly positive integer.
\item The dyadic matrix must be numeric and free of \code{NA} values.
Any \code{NA} triggers a fail-fast error. Symmetry is \emph{not}
required: the C code always uses the symmetrised combination
\code{z_ij + z_ji} for each unordered pair \code{\{i,j\}}.
\item Debug logging is controlled by the global option
\code{options(ERPM.dyadcov_GW.debug = TRUE/FALSE)}. When \code{TRUE},
the initializer prints diagnostic messages prefixed by
\code{"[dyadcov_GW][DEBUG]"} and may report how far the dyadic
matrix is from symmetry.
}
}
\section{Definition}{

T_GW(p; Z, lambda)
= sum_g sum_{k = 2..n_g} a_k(lambda) * S_g^{(k)}(Z)
= sum_g sum_{k = 2..n_g} (-1/lambda)^{k-1}
* sum_{C in C_k(g)} prod_{i<j in C} (z_{ij} + z_{ji})

where:
\itemize{
\item \eqn{g} ranges over group-mode nodes (groups);
\item \eqn{n_g} is the number of actors attached to group \eqn{g};
\item \eqn{C_k(g)} is the set of all actor subsets \eqn{C} of size \eqn{k}
within group \eqn{g};
\item \eqn{S_g^{(k)}(Z)} is the raw \eqn{k}-clique sum
\eqn{\sum_{C \in C_k(g)} \prod_{i<j \in C} (z_{ij}+z_{ji})};
\item \eqn{a_k(\lambda) = (-1/\lambda)^{k-1}} is the geometric weight
applied to clique size \eqn{k}.
}

The dyadic covariate \eqn{Z} is a real actor-by-actor matrix of
size \eqn{n_A \times n_A}, where \eqn{n_A} is the size of the actor mode
\code{n1 = nw \%n\% "bipartite"}. Symmetry is \strong{not} required:
both \eqn{z_{ij}} and \eqn{z_{ji}} are used for each unordered pair
\eqn{\{i,j\}} when available. The initializer:
\itemize{
\item enforces that the network is bipartite and retrieves the actor-mode size;
\item accepts \code{dyadcov} as either a literal matrix or the name of a
network-level attribute (\code{nw \%n\% "..."});
\item truncates \code{dyadcov} to its top-left \code{n1 x n1} block if
larger than required;
\item checks that \code{dyadcov} is numeric and free of \code{NA};
\item optionally reports (in debug mode) how far the matrix is from being
symmetric, but does not require symmetry.
}
}

\section{Implementation and change-statistic}{

The term is implemented as a native ERGM C change-statistic, exposed under the
symbol \code{c_dyadcov_GW}. The R initializer below:
\itemize{
\item packages \code{n1}, \code{lambda} and the flattened \code{dyadcov}
matrix into \code{INPUT_PARAM};
\item declares the term as dependent (\code{dependence = TRUE}) with
unbounded support (\code{minval = -Inf}, \code{maxval = Inf});
\item sets the empty-network statistic to \code{0}.
}

On each toggle of an actor–group edge, the C change-statistic recomputes the
local contribution for the unique group touched by the toggle, updating the
geometrically weighted sum over clique contributions
\eqn{\{S_g^{(k)}(Z)\}_{k \ge 2}} based on the symmetrised dyadic covariate
\eqn{z_{ij}+z_{ji}}.
}

\section{Arguments}{

The initializer is not called directly by users; it is invoked automatically
by {ergm} when the term \code{dyadcov_GW(...)} appears on the right-hand
side of a model formula.
}

\section{Tests}{

Self-tests for \code{dyadcov_GW} (not shown here) typically:
\itemize{
\item construct small bipartite networks with a known partition of actors
into groups;
\item define dyadic matrices \code{Z} (symmetric or not) where clique
products based on \code{z_ij + z_ji} and their geometric weights
\eqn{(-1/\lambda)^{k-1}} can be computed explicitly;
\item compare \code{summary(nw ~ dyadcov_GW(...), constraints = ~ b1part)}
with a direct R implementation of
\code{sum_g sum_{k >= 2} (-1/lambda)^{k-1} * S_g^{(k)}(Z)};
\item apply explicit edge toggles and check that observed changes match
the Δ produced by \code{c_dyadcov_GW}.
}
}

\examples{
\dontrun{
  library(network)
  library(ergm)

  # -------------------------------------------------------------------------
  # Build a toy bipartite network: 4 actors, 2 groups
  # -------------------------------------------------------------------------
  n_actors <- 4
  n_groups <- 2
  n_total  <- n_actors + n_groups

  adj <- matrix(0, n_total, n_total)

  # Actors = 1..4, Groups = 5..6
  # Group 5 has actors 1, 2, 3
  adj[1, 5] <- adj[5, 1] <- 1
  adj[2, 5] <- adj[5, 2] <- 1
  adj[3, 5] <- adj[5, 3] <- 1
  # Group 6 has actors 3, 4
  adj[3, 6] <- adj[6, 3] <- 1
  adj[4, 6] <- adj[6, 4] <- 1

  nw <- network(adj, directed = FALSE, matrix.type = "adjacency")
  nw \%n\% "bipartite" <- n_actors  # actor-mode size

  # -------------------------------------------------------------------------
  # Build a (possibly non-symmetric) dyadic covariate on actors
  # -------------------------------------------------------------------------
  Z <- matrix(
    c(
      0, 1, 2, 3,
      10, 0, 4, 5,
      20, 40, 0, 6,
      30, 50, 60, 0
    ),
    n_actors, n_actors, byrow = TRUE
  )
  nw \%n\% "Z_example" <- Z

  # -------------------------------------------------------------------------
  # Inspect the dyadcov_GW statistic
  # -------------------------------------------------------------------------
  # Geometrically weighted aggregation with lambda = 2
  summary(
    nw ~ dyadcov_GW("Z_example", lambda = 2),
    constraints = ~ b1part
  )
}

}
\keyword{ERGM}
\keyword{bipartite}
\keyword{cliques}
\keyword{covariate}
\keyword{dyadic}
\keyword{geometrically-weighted}
\keyword{term}
