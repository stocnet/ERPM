% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.dyadcov.R
\name{InitErgmTerm.dyadcov}
\alias{InitErgmTerm.dyadcov}
\alias{dyadcov}
\title{ERGM term: dyadcov (clique-based dyadic covariate)}
\usage{
InitErgmTerm.dyadcov(nw, arglist, ...)
}
\arguments{
\item{dyadcov}{matrix or character. Either:
\itemize{
\item a numeric matrix of size at least \code{n1 x n1}, where
\code{n1 = nw \%n\% "bipartite"} is the actor-mode size; or
\item the name of a network-level attribute containing such a matrix
(retrieved as \code{nw \%n\% dyadcov}).
}
In both cases the matrix is truncated, if necessary, to its top-left
\code{n1 x n1} block.}

\item{clique_size}{numeric or integer scalar. Target clique size \eqn{k}.
It is rounded and coerced to an integer and must satisfy \eqn{k \ge 2}.
Defaults to \code{2}.}

\item{normalized}{logical scalar. When \code{FALSE}, the statistic is a raw
sum over all \eqn{k}-cliques per group. When \code{TRUE}, each group's
clique-based sum \eqn{S_g^{(k)}(Z)} is multiplied by \eqn{1 / n_g} (and
groups with \eqn{n_g < k} contribute \code{0} since they have no
\eqn{k}-cliques). Defaults to \code{FALSE}.}
}
\value{
A standard {ergm} term initialization list with components:
\itemize{
\item \code{name}         = \code{"dyadcov"};
\item \code{coef.names}   = a single coefficient name encoding
\code{dyadcov} label, \code{k} and the normalization flag;
\item \code{inputs}       = numeric vector
\code{c(n1, k, normalized_flag, as.double(Z))};
\item \code{dependence}   = \code{TRUE};
\item \code{minval}       = \code{-Inf};
\item \code{maxval}       = \code{Inf};
\item \code{emptynwstats} = \code{0}.
}
}
\description{
\code{dyadcov} is an ERGM term for bipartite networks that aggregates a
numeric dyadic covariate \eqn{Z = (z_{ij})} over cliques of actors within
each group. The network is interpreted as:
\itemize{
\item an \emph{actor mode} (the side identified by \code{nw \%n\% "bipartite"});
\item a \emph{group mode} (the complementary side of the bipartite graph).
}

For each group node in the group mode, we consider the set of adjacent actors
and all \eqn{k}-cliques of actors within that group. For a given clique
\eqn{C} of size \eqn{k}, the contribution is the product of dyadic covariates
over all actor pairs in the clique. For each unordered pair \eqn{\{i,j\}} with
\eqn{i<j}, the term uses the sum of both orientations:
\deqn{
  \prod_{i<j,\, i,j \in C} (z_{ij} + z_{ji}).
}
If \eqn{Z} is symmetric, each factor reduces to \eqn{2 z_{ij}}.

Two variants are supported:
\itemize{
\item \code{normalized = FALSE} (raw sum over cliques);
\item \code{normalized = TRUE} (per-group scaling of the clique sum by
the group size \eqn{n_g}, i.e. a factor \eqn{1 / n_g} whenever
\eqn{n_g \ge k}).
}
}
\details{
The dyadic covariate \eqn{Z} is a real actor-by-actor matrix of size
\eqn{n_A \times n_A}, where \eqn{n_A} is the size of the actor mode
(\code{n1 = nw \%n\% "bipartite"}). The matrix is allowed to be non-symmetric;
both \eqn{z_{ij}} and \eqn{z_{ji}} are read whenever available, through the
symmetric combination \eqn{z_{ij} + z_{ji}}. The initializer:
\itemize{
\item enforces bipartiteness and retrieves the actor-mode size \eqn{n_A};
\item accepts \code{dyadcov} either as a literal matrix or as the name of a
network-level attribute (\code{nw \%n\% "..."});
\item truncates \code{dyadcov} to its top-left \code{n1 x n1} block if larger;
\item checks that \code{dyadcov} is numeric and free of \code{NA};
\item optionally reports (in debug mode) how far the matrix is from being
symmetric, but does not require symmetry;
\item parses \code{clique_size} into an integer \eqn{k \ge 2};
\item parses \code{normalized} into a logical flag.
}
}
\note{
InitErgmTerm.dyadcov.R

\itemize{
\item The network must be bipartite and interpreted as actors versus groups.
\item The actor mode is identified by \code{nw \%n\% "bipartite"} and must
be a positive integer.
\item The dyadic matrix must be numeric and free of \code{NA} values.
Any \code{NA} triggers a fail-fast error. Symmetry is not required;
when the matrix is not symmetric, both \eqn{z_{ij}} and \eqn{z_{ji}}
are used through the sum \eqn{z_{ij} + z_{ji}}.
\item Debug logging is controlled by the global option
\code{options(ERPM.dyadcov.debug = TRUE/FALSE)}. When \code{TRUE},
the initializer prints diagnostic messages prefixed by
\code{"[dyadcov][DEBUG]"} and may report how far the dyadic matrix
is from symmetry.
}
}
\section{Core statistic}{

The core statistic (for a fixed \eqn{k} and scalar \code{normalized}) can be
written in terms of the partition \eqn{p} and the dyadic covariate \eqn{Z}:
\itemize{
\item normalized = FALSE :
T^{(k)}(p; Z)
= sum_g sum_{C in C_k(g)} prod_{i<j in C} (z_{ij} + z_{ji})
\item normalized = TRUE :
T^{(k)}\emph{norm(p; Z)
= sum_g 1(n_g >= k) * (1 / n_g) *
sum}{C in C_k(g)} prod_{i<j in C} (z_{ij} + z_{ji})
}

where:
\itemize{
\item \eqn{g} runs over group-mode nodes (groups);
\item \eqn{n_g} is the number of actors adjacent to group \eqn{g};
\item \eqn{C_k(g)} is the set of all subsets \eqn{C \subseteq A(g)} of size
\eqn{k}, where \eqn{A(g)} is the actor set attached to group \eqn{g}.
}

For \eqn{k = 2} and \code{normalized = FALSE}, this reduces to:
\deqn{
  T^{(2)}(p; Z)
    = \sum_g \sum_{i<j,\, i,j \in A(g)} (z_{ij} + z_{ji}),
}
which matches the definition of \code{dyadcov_full(dyadcov, size = NULL)}
aggregating the dyadic covariate over all ordered pairs of co-grouped actors.
For \eqn{k = 2} and \code{normalized = TRUE}, each group contribution is
additionally scaled by \eqn{1 / n_g}.
}

\section{Implementation and change-statistic}{

The term is implemented as a native ERGM C change-statistic, exposed under the
symbol \code{c_dyadcov}. The R initializer below:
\itemize{
\item packages \code{n1}, \code{k}, \code{normalized} and the flattened
\code{dyadcov} matrix into \code{INPUT_PARAM};
\item declares the term as dependent (\code{dependence = TRUE}) with no
finite \code{minval}/\code{maxval};
\item sets the empty-network statistic to \code{0}.
}

On each toggle of an actor–group edge, the C change-statistic recomputes the
local contribution for the unique group affected by the toggle, by updating
the clique-based sums according to the new set of actors in that group and,
when \code{normalized = TRUE}, dividing by the current group size \eqn{n_g}
(if \eqn{n_g \ge k}).
}

\section{Arguments}{

The initializer is not called directly by users; it is invoked automatically
by {ergm} when the term \code{dyadcov(...)} appears on the right-hand side of
a model formula.
}

\section{Tests}{

Self-tests for \code{dyadcov} (not shown here) typically:
\itemize{
\item build small bipartite networks with a known partition of actors into
groups;
\item define dyadic matrices \code{Z} (symmetric or not) so that clique
products can be computed analytically using \code{z_ij + z_ji};
\item compare \code{summary(nw ~ dyadcov(...), constraints = ~ b1part)} with
a direct implementation of
\code{sum_g 1(n_g >= k) / n_g * sum_{C in C_k(g)} prod_{i<j in C}(Z[i,j]+Z[j,i])}
(raw or normalized);
\item verify that toggling a single actor–group edge changes the statistic
by the local difference between the "before" and "after" clique sums
(with or without the 1 / n_g factor), in agreement with the C
change-statistic \code{c_dyadcov}.
}
}

\examples{
\dontrun{
  library(network)
  library(ergm)

  # -------------------------------------------------------------------------
  # Build a toy bipartite network: 4 actors, 2 groups
  # -------------------------------------------------------------------------
  n_actors <- 4
  n_groups <- 2
  n_total  <- n_actors + n_groups

  adj <- matrix(0, n_total, n_total)

  # Actors = 1..4, Groups = 5..6
  # Group 5 has actors 1, 2, 3
  adj[1, 5] <- adj[5, 1] <- 1
  adj[2, 5] <- adj[5, 2] <- 1
  adj[3, 5] <- adj[5, 3] <- 1
  # Group 6 has actors 3, 4
  adj[3, 6] <- adj[6, 3] <- 1
  adj[4, 6] <- adj[6, 4] <- 1

  nw <- network(adj, directed = FALSE, matrix.type = "adjacency")
  nw \%n\% "bipartite" <- n_actors  # actor-mode size

  # -------------------------------------------------------------------------
  # Build a dyadic covariate on actors (symmetric or not)
  # -------------------------------------------------------------------------
  Z <- matrix(
    c(
      0, 1,  2,  3,
      10, 0, 4,  5,
      20, 40, 0, 6,
      30, 50, 60, 0
    ),
    n_actors, n_actors, byrow = TRUE
  )
  nw \%n\% "Z_example" <- Z

  # -------------------------------------------------------------------------
  # Inspect the dyadcov statistic
  # -------------------------------------------------------------------------
  # k = 2, raw sum over all cliques of size 2 (pairs) within groups,
  # using (z_ij + z_ji) for each pair {i,j}
  summary(nw ~ dyadcov("Z_example", clique_size = 2, normalized = FALSE),
          constraints = ~ b1part)

  # k = 3, per-group normalisation by 1 / n_g on 3-cliques
  summary(nw ~ dyadcov("Z_example", clique_size = 3, normalized = TRUE),
          constraints = ~ b1part)

  # -------------------------------------------------------------------------
  # Example with the ERPM wrapper (network already bipartite)
  # -------------------------------------------------------------------------
  # erpm(nw ~ dyadcov("Z_example", clique_size = 2))
}

}
\keyword{ERGM}
\keyword{bipartite}
\keyword{cliques}
\keyword{covariate}
\keyword{dyadic}
\keyword{term}
