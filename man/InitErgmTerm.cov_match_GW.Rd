% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.cov_match_GW.R
\name{InitErgmTerm.cov_match_GW}
\alias{InitErgmTerm.cov_match_GW}
\title{ERGM term: cov_match_GW (geometrically weighted monochromatic cliques)}
\usage{
InitErgmTerm.cov_match_GW(nw, arglist, ..., version = packageVersion("ergm"))
}
\arguments{
\item{cov}{character
Name of an actor-level vertex attribute (factor/character) defined on all
actors in the actor mode. The attribute is coerced to a factor and then
encoded as integer codes \eqn{1,\dots,R}; \code{NA} values are mapped to 0
(meaning "absent/undefined" and ignored in the counts).}

\item{lambda}{numeric
Scalar or numeric vector of \eqn{\lambda} values. Each \eqn{\lambda} must
be finite and strictly greater than 1. The internal ratio
\eqn{r_\lambda = (\lambda-1)/\lambda} drives the geometric weighting. A
vector of \eqn{\lambda} values yields one statistic per value.}

\item{category}{character|NULL
Optional targeted category. If \code{NULL}, all categories contribute to
the statistic. If a character string, the initializer ensures that the
category appears in the factor levels; if it does not, the level is added
with zero frequency so that the resulting statistic is structurally zero
without error.}

\item{normalized}{character|logical
Normalization mode, one of:
\itemize{
\item \code{"none"}: raw geometrically weighted contributions;
\item \code{"by_group"}: per-group normalization by a GW-size-like
denominator \eqn{\lambda(1 - r_\lambda^{n_g})};
\item \code{"global"}: normalization by \eqn{\lambda(1 - r_\lambda^{N_A})}.
}
Logical values are supported as shorthand:
\code{TRUE} is equivalent to \code{"by_group"} and \code{FALSE} to
\code{"none"}.}
}
\value{
A standard {ergm} term specification list with components:
\itemize{
\item \code{name}         = \code{"cov_match_GW"};
\item \code{coef.names}   = coefficient names encoding the covariate label,
\eqn{\lambda} value and normalization mode;
\item \code{inputs}       = the \code{INPUT_PARAM} numeric vector described
above;
\item \code{dependence}   = \code{TRUE};
\item \code{emptynwstats} = \code{0}.
}
}
\description{
\code{cov_match_GW} is an ERGM term for bipartite networks that applies a
geometrically weighted transform to the monochromatic clique counts produced
by \code{cov_match}, based on a categorical actor-level covariate.

The network is interpreted as:
\itemize{
\item an \emph{actor mode} (the side identified by \code{nw \%n\% "bipartite"});
\item a \emph{group mode} (the complementary side of the bipartite graph).
}

For each group in the group mode and each category of the actor covariate, the
term replaces raw counts of monochromatic cliques by a geometrically weighted
function driven by \eqn{\lambda > 1}, with ratio
\deqn{
  r_\lambda = \frac{\lambda - 1}{\lambda} \in (0, 1).
}

Several normalization variants are supported (\code{"none"}, \code{"by_group"},
\code{"global"}), as well as an optional targeted category.
}
\details{
Let:
\itemize{
\item \eqn{A} be the set of actor-mode nodes, with \eqn{|A| = N_A};
\item \eqn{G} be the set of group-mode nodes;
\item \eqn{B} be the actor–group incidence (bipartite) matrix;
\item \eqn{c : A \to \{1,\dots,R\}} be a categorical covariate assigning a
category \eqn{r} to each actor;
\item \eqn{n_{g,r}} be the number of actors of category \eqn{r} attached to
group \eqn{g};
\item \eqn{n_g = \sum_r n_{g,r}} be the size of group \eqn{g}.
}

For a fixed \eqn{\lambda > 1}, define:
\deqn{
  r_\lambda = \frac{\lambda - 1}{\lambda},
}
and for each group \eqn{g} and category \eqn{r},
\deqn{
  S_{g,r}^{\text{GW}}(B; c, \lambda)
  = \lambda \cdot \left(1 - r_\lambda^{n_{g,r}}\right).
}

The non-normalized aggregate is:
\deqn{
  S_{\text{GW}}(B; c, \lambda)
  = \sum_{g \in G} \sum_{r=1}^R S_{g,r}^{\text{GW}}(B; c, \lambda)
  = \sum_{g \in G} \sum_{r=1}^R \lambda \cdot \left(1 - r_\lambda^{n_{g,r}}\right).
}

When a targeted category \eqn{\kappa} is specified, we restrict to:
\deqn{
  S_{\text{GW}}^{(\kappa)}(B; c, \lambda)
  = \sum_{g \in G} \lambda \cdot \left(1 - r_\lambda^{n_{g,\kappa}}\right).
}

For the normalization modes, let:
\itemize{
\item \eqn{\text{Num}(g)} be the non-normalized group-level contribution
(either \eqn{\sum_r \lambda(1 - r_\lambda^{n_{g,r}})} or
\eqn{\lambda(1 - r_\lambda^{n_{g,\kappa}})} for a targeted category);
\item \eqn{\text{Den}(g) = \lambda(1 - r_\lambda^{n_g})} be a group-size
denominator reminiscent of a geometrically weighted size term.
}

Then:
\itemize{
\item \code{normalized = "none"}:
\deqn{
      T(B; c, \lambda) =
      \begin{cases}
        S_{\text{GW}}(B; c, \lambda) & \text{if no category is targeted}, \\
        S_{\text{GW}}^{(\kappa)}(B; c, \lambda) & \text{if category } \kappa \text{ is targeted};
      \end{cases}
    }
\item \code{normalized = "by_group"}:
\deqn{
      T_{\text{by\_group}}(B; c, \lambda)
      = \sum_{g \in G} \frac{\text{Num}(g)}{\text{Den}(g)};
    }
\item \code{normalized = "global"}:
using \eqn{\text{Den}_{\text{glob}} = \lambda(1 - r_\lambda^{N_A})},
\deqn{
      T_{\text{global}}(B; c, \lambda)
      = \frac{\sum_{g \in G} \text{Num}(g)}{\text{Den}_{\text{glob}}}.
    }
}

The term is vectorized in \code{lambda}: providing a vector of \eqn{\lambda}
values produces one statistic (and one coefficient) per value.

The term is implemented as a native ERGM C change-statistic
\code{c_cov_match_GW}. The R initializer below:
\itemize{
\item enforces that the network is bipartite and retrieves the actor-mode
size from \code{nw \%n\% "bipartite"};
\item validates that \code{cov} names a categorical actor attribute;
\item handles the optional targeted category by mapping it to a level index;
\item maps the normalization choice to an internal integer flag;
\item builds a compact \code{INPUT_PARAM} vector encoding the actor-mode
size, the \eqn{\lambda} values, normalization mode, and covariate
codes.
}
}
\note{
InitErgmTerm.cov_match_GW.R

\itemize{
\item The network must be bipartite and interpreted as actors versus
groups. The actor mode is identified by \code{nw \%n\% "bipartite"}
and must be a strictly positive integer.
\item The covariate must be categorical (factor or character) and is
interpreted on the actor mode. Numeric attributes are not supported
here; for numeric covariates you should use terms such as
\code{cov_diff_GW} or related effects.
\item All \eqn{\lambda} values must be strictly greater than 1; when
\eqn{\lambda \to 1^+}, the ratio \eqn{r_\lambda} approaches 0 and the
weighting tends to emphasize small counts.
}
}
\section{INPUT_PARAM layout (C side)}{

The numeric input vector passed to \code{c_cov_match_GW} is:

\preformatted{
  INPUT_PARAM = c(
    n1,          # actor-mode size |A|
    K,           # number of distinct lambda values
    norm_mode,   # 0=none, 1=by_group, 2=global
    has_kappa,   # 0/1: whether a targeted category is used
    kappa_code,  # level index of the targeted category (0 if none)
    lambdas[1:K],
    z[1:n1]      # actor covariate codes (0=missing / undefined, 1..R for levels)
  )
}

On each toggle of an actor–group edge, the C code recomputes the local
contribution for the affected group (for each \eqn{\lambda}) and updates the
statistics accordingly, respecting the chosen normalization and targeted
category.
}

\section{User-facing term}{

The initializer is called internally by {ergm} and should not be invoked
directly by users. The user-facing term is:

\preformatted{
  cov_match_GW(cov,
               lambda     = 2,
               category   = NULL,
               normalized = c("none","by_group","global"))
}
}

\section{Tests}{

Self-tests for \code{cov_match_GW} (not shown here) typically:
\itemize{
\item construct small bipartite networks with a known actor partition
into groups and a categorical covariate on actors;
\item choose several \eqn{\lambda} values and compute, in pure R, the
reference quantities \eqn{S_{\text{GW}}(B; c, \lambda)} and their
by-group and global normalizations;
\item compare these reference values to
\code{summary(nw ~ cov_match_GW(...), constraints = ~ b1part)};
\item verify that toggling a single actor–group edge changes the statistic
by an increment consistent with the local recalculation of the
group-level contributions for the affected group, as implemented in
the C change-statistic \code{c_cov_match_GW}.
}
}

\examples{
\dontrun{
  library(network)
  library(ergm)

  # -----------------------------------------------------------------------
  # Build a small bipartite network: 5 actors, 2 groups
  # -----------------------------------------------------------------------
  n_actors <- 5
  n_groups <- 2
  n_total  <- n_actors + n_groups

  adj <- matrix(0, n_total, n_total)

  # Actors = 1..5, Groups = 6..7
  # Group 6: actors 1, 2, 3
  adj[1, 6] <- adj[6, 1] <- 1
  adj[2, 6] <- adj[6, 2] <- 1
  adj[3, 6] <- adj[6, 3] <- 1
  # Group 7: actors 3, 4, 5
  adj[3, 7] <- adj[7, 3] <- 1
  adj[4, 7] <- adj[7, 4] <- 1
  adj[5, 7] <- adj[7, 5] <- 1

  nw <- network(adj, directed = FALSE, matrix.type = "adjacency")
  nw \%n\% "bipartite" <- n_actors  # actor-mode size

  # Actor covariate: two categories "A" / "B"
  cov_vals <- c("A", "A", "B", "B", "A")
  set.vertex.attribute(nw, "grp", c(cov_vals, rep(NA, n_groups)))

  # -----------------------------------------------------------------------
  # Example 1: single lambda, non-normalized
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match_GW("grp", lambda = 2, normalized = "none"),
    constraints = ~ b1part
  )

  # -----------------------------------------------------------------------
  # Example 2: by-group normalization, targeted category
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match_GW("grp", lambda = 2.5,
                      category   = "A",
                      normalized = "by_group"),
    constraints = ~ b1part
  )

  # -----------------------------------------------------------------------
  # Example 3: multiple lambda values, global normalization
  # -----------------------------------------------------------------------
  summary(
    nw ~ cov_match_GW("grp",
                      lambda     = c(1.5, 3),
                      normalized = "global"),
    constraints = ~ b1part
  )

  # Example ERGM fit combining different lambda values
  fit <- ergm(
    nw ~ cov_match_GW("grp",
                      lambda     = c(1.5, 3),
                      normalized = "by_group"),
    constraints = ~ b1part
  )
  summary(fit)
}

}
\keyword{ERGM}
\keyword{bipartite}
\keyword{categorical}
\keyword{covariate}
\keyword{geometrically}
\keyword{term}
\keyword{weighted}
